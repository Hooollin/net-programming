# 多线程服务器的使用场景和常用编程模型

## 进程与线程
本书的进程指的是Linux操作系统通过fork()系统调用产生的那个东西，是比较重量级的对象。  

可以把进程比作一个人，每个人都有memory，人与人之间通过谈话（消息传递）来交流，可以面谈（同一个服务器），也可以在电话里谈（不同的服务器，网络通信）。面谈可以立即知道对方是否还或者（crash, SIGCHLD），而电话只可以通过周期性的心跳去判断对方是否还或者。  

线程在1993年以后流行起来，在1995年，POSIX threads标准确立。  

线程的特点是共享地址空间，从而可以高效的共享数据。  

## 单线程服务器的常用模型
高性能网络程序中，使用的最为广泛的要数“non-blocking IO + IO multiplexing”，称为Reactor模式，使用这种服务器的有：
- lighttpd，单线程服务器。
- libevent，libev。
- ACE，Poco C++ libraries。
- Java NIO，包括Apache Mina和Netty。
- POE。
- Twisted。

在“non-blocking IO + IO multiplexing”这种模型中，程序的基本结构是一个事件循环（event loop），以事件驱动（event-driven）和事件回调的方式实现业务逻辑：

```C++
while(!done){
    int timeout_ms = max(1000, getNextTimedCallback());
    int retval = ::poll(fds, nfds, timeout_ms);
    if(retval < 0){
        处理错误，或掉用户的error handler
    }else{
        处理到期的timers，回调用户的timer handler
            if(retval > 0){
                处理IO事件，回调用户的IO event handler
            }
    }
}
```
select和poll有伸缩性方面的不足，Linux下可替换为epoll，其他操作系统中也有对应的高性能替代品。  

## 多线程服务器的常用编程模型
- 为每个请求创建一个线程，使用阻塞式IO操作。
- 使用线程池，同样使用阻塞式IO操作，提高了部分性能。
- 使用non-blocking IO + IO multiplexing。
- Leader/Follower等高级模式。

默认情况下，作者更青睐第三种的模式来编写多线程C++网络服务程序。

### one loop per thread
程序里的每个IO线程有一个event loop（Reactor），用户处理读写和定时事件（周期或单次），代码框架如上。

> One loop per thread is usually a good model. Doing this is almost never wrong, sometimes a better-performance model exists, but it is always a good start. 

这种方式的优点是：
- 线程数基本固定，可以在程序启动的时候设置，不会频繁的创建与销毁。
- 可以很方便的在线程间调配负载。
- IO事件发生的线程是固定的，同一个TCP连接不必考虑事件并发。

Event loop代表了线程的主循环，需要让哪个线程干活，就把timer或IO channel注册到哪个线程的Loop里即可。
