# 多线程服务器的使用场景和常用编程模型

## 进程与线程
本书的进程指的是Linux操作系统通过fork()系统调用产生的那个东西，是比较重量级的对象。  

可以把进程比作一个人，每个人都有memory，人与人之间通过谈话（消息传递）来交流，可以面谈（同一个服务器），也可以在电话里谈（不同的服务器，网络通信）。面谈可以立即知道对方是否还或者（crash, SIGCHLD），而电话只可以通过周期性的心跳去判断对方是否还或者。  

线程在1993年以后流行起来，在1995年，POSIX threads标准确立。  

线程的特点是共享地址空间，从而可以高效的共享数据。  

## 单线程服务器的常用模型
高性能网络程序中，使用的最为广泛的要数“non-blocking IO + IO multiplexing”，称为Reactor模式，使用这种服务器的有：
- lighttpd，单线程服务器。
- libevent，libev。
- ACE，Poco C++ libraries。
- Java NIO，包括Apache Mina和Netty。
- POE。
- Twisted。

在“non-blocking IO + IO multiplexing”这种模型中，程序的基本结构是一个事件循环（event loop），以事件驱动（event-driven）和事件回调的方式实现业务逻辑：

```C++
while(!done){
    int timeout_ms = max(1000, getNextTimedCallback());
    int retval = ::poll(fds, nfds, timeout_ms);
    if(retval < 0){
        处理错误，或掉用户的error handler
    }else{
        处理到期的timers，回调用户的timer handler
            if(retval > 0){
                处理IO事件，回调用户的IO event handler
            }
    }
}
```
select和poll有伸缩性方面的不足，Linux下可替换为epoll，其他操作系统中也有对应的高性能替代品。  

## 多线程服务器的常用编程模型
- 为每个请求创建一个线程，使用阻塞式IO操作。
- 使用线程池，同样使用阻塞式IO操作，提高了部分性能。
- 使用non-blocking IO + IO multiplexing。
- Leader/Follower等高级模式。

默认情况下，作者更青睐第三种的模式来编写多线程C++网络服务程序。

### one loop per thread
程序里的每个IO线程有一个event loop（Reactor），用户处理读写和定时事件（周期或单次），代码框架如上。

> One loop per thread is usually a good model. Doing this is almost never wrong, sometimes a better-performance model exists, but it is always a good start. 

这种方式的优点是：
- 线程数基本固定，可以在程序启动的时候设置，不会频繁的创建与销毁。
- 可以很方便的在线程间调配负载。
- IO事件发生的线程是固定的，同一个TCP连接不必考虑事件并发。

Event loop代表了线程的主循环，需要让哪个线程干活，就把timer或IO channel注册到哪个线程的Loop里即可。
对实时性有要求的connection可以单独用一个线程；数据量大的connection可以独占一个线程，并且把处理任务分摊到另外几个计算线程中（线程池）；辅助性的connections可以共享一个线程。  

对于non-trivial的服务端程序，一般会采用non-blocking IO + IO multiplexing，每个connection都会注册到某个event loop上，程序中有多个event loop，每个线程至多有一个event loop。

### 线程池
如果对于没有IO而光有计算任务的线程，使用event loop比较浪费，作者提出一个补充方案，使用blocking queue实现的任务队列（TaskQueue）：  
```C++
typedef function<void()> Functor;
BlockingQueue<Functor> taskQueue;

void workerThread(){
  while(running){     //running是全局标志
    Functor task = taskQueue.take();
    task();
  }
}

// 启动并发数为N的线程
int N = num_of_cumputing_threads;
for(int i = 0; i < N; ++i){
  create_thread(&workerThread);
}


// 使用
Foo foo;
fucntion<void()> task = bind(&Foo::calc, &foo);
taskQueue.post(task);
```

### 推荐模式
作者推荐的C++多线程服务端编程模式为：one loop per thread + thread pool.
- event loop（IO loop）用作IO multiplexing，配合non-blocking IO和定时器。
- thread pool用来做计算，任务队列或生产者消费者队列。

以这种方式写服务器程序，需要一个优质的基于Reactor模式的网络库来支撑，所以有了muduo。  


