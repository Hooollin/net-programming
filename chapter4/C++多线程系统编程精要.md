# C++多线程系统编程精要
多线程编程面临的思维方式的转变有：
- 当前线程可能随时被切换出去（被抢占）。
- 多线程程序中事件的发生不再有全局统一的先后关系了。

在多核系统中，多个线程是并发执行的，没有统一的全局时钟为每个事件编号。在没有适当同步的情况的下，多个CPU上运行的多个线程中的事件发生先后顺序是无法确定的。在引入适当同步后，事件之间才有happens-before的关系。  

## 基本线程原语的使用

常用的Pthreads函数有：
- 线程的创建和等待结束。
- mutex的创建、销毁、加锁、解锁。
- 条件变量的创建、销毁、等待、通知、广播。

可以酌情使用的有：
- pthread\_once。
- pthread\_key\*。threadlocal变量。

不建议使用的有：
- pthread\_rwlock。
- sem\_\*。
- pthread\_{cancel, kill}。系统中如果出现了他们，通常意味着设计出了问题。

不推荐使用读写锁的原因是因为它造成了提高性能的错觉，实际上在很多情况下，与使用最简单的mutex想不，实际上降低了性能。另外，写操作是会阻塞读操作的，如果要求优化读操作的延迟，用读写锁是不合适的。  

## C/C++系统库的线程安全性
对于标准而言，关键的不是定义线程库，而是规定内存模型（memory model）。特别规定一个线程对某个共享变量的修改何时能被其他线程看到，这称为内存序（memory ordering）或内存能见度（memory visibility）。  
绝大部分系统调用都是thread safe的（虽然没有去看是怎么实现thread safe的，姑且在这里认为是加锁的方法）。但是编写安全程序的一个难点在于线程安全是不可组合的，即使调用了两个线程安全的函数，也不能认为这两个函数构成的函数是线程安全的。  

## Linux上的线程标识
不应该使用pthread\_self来标识线程。可以通过pid\_t获取线程id，同时将线程安全的pid\_t换存在thread local中，避免了大量的系统调用。  

## 线程的创建与销毁准则
线程的创建需要准讯的准则：
- 程序不应该在未提前告知的情况下创建自己的“背景线程”。
- 尽量使用相同的方式创建线程。
- 进入main函数之前不应该启动线程。
- 线程的创建最好能在初始化阶段全部完成。

线程销毁的几种方式：
- 自然死亡。从主函数返回，线程正常退出。
- 非自然死亡。从线程主函数抛出异常或线程触发segfault信号等。
- 自杀。
- 他杀。

作者认为不应该从外部杀死线程。  

## 多线程与IO
在进行多线程网络编程的时候，几个自然的问题是：
- 如何处理IO？
- 能否多个线程同时读写同一个socket文件描述符？
- 用多个线程同时处理一个sokcet也可以提高效率吗？

操作文件描述符的系统调用本身是线程安全的，不需要担心多个线程同时操作文件描述符会造成进程崩溃或内核崩溃。作者认为，多个线程同时操作同一个socket文件描述符确实很麻烦，是得不偿失的。需要考虑的情况有：
- 如果一个线程正在阻塞地read某个socket，而另一个线程close了这个socket。
- 如果一个线程正在阻塞地accept某个listening socket，而另一个线程close了这个socket。
- 更糟糕的是，一个线程正主编内read某个socket，而另一个线程close了这个socket。第三个线程又恰好open了另一个文件描述符，fd正好与之前的socket相同，程序的逻辑就混乱了。

如果不考虑关闭文件描述符，只考虑读写，也会产生糟糕的情况，因为socket的读写不保证完整性：
- 如果两个线程同时read一个socket，各自收到一部分数据，如何把数据拼成完整的消息？如何知道哪部分数据先到达？
- 写的问题是一样的，如果两个线程同时写了一部分的消息，接收方怎么处理？
- 对非阻塞IO而言，收发消息的完整性与原子性几乎不可能用锁来保证，因为这样会阻塞其他的IO线程。

从上面的例子中可以看到，用多线程读同一个socket是行不通的。由于TCP的全双工通信，可以把read和write拆分到两个线程去吗？问题是真的值得拆分吗？  

在磁盘IO的环境下，多线程可以加速磁盘IO吗？首先要避免lseek(2)和read(2)的race condition。作者认为用多个线程read或write同一个文件也不会提速。不仅如此，多个线程分别read或write同一个磁盘上的多个文件也不见得能提速。每块磁盘都有一个操作队列，多个线程的多谢请求到了内核时排队执行的，只有在内核缓存了大部分数据的情况下，多线程读这些热数据才可能比单线程快。多线程磁盘IO的一个思路是每个磁盘配一个线程，把所有对此磁盘的IO都挪到同一个线程，或许能避免或减少内核的锁争用。  

作者认为应该遵守的原则是：**每个文件描述符只由一个线程操作，从而轻松解决消息收发的顺序性问题，也避免了关闭文件描述符的各种race condition。**一个线程可以操作多个文件描述符，但一个线程不能操作别的线程拥有的文件描述符。  

epoll也应该遵循相同的原则。当一个线程阻塞在epoll\_wait()上时，另一个线程往epoll fd添加一个新的监视fd会发生什么。新fd上的时间会不会在此epoll\_wait()调用中返回？作者认为需要把对同一个epoll fd的操作都放到同一个线程中执行。


## 用RAII包装文件描述符
程序刚刚启动时，0是标准输入，1是标准输出，2是标准错误。如果打开一个新的文件，它的文件描述符会是3。POSIX标准要求每次新打开文件的时候必须使用当前最小可用的文件描述符号码。  
这种文件描述符分配方案下，稍不注意就会造成串话。在单线程程序中，或许可以通过某种全局表来避免串话；在多线程程序中，这种做法并不高效。  
通过RAII可以轻松解决这个问题。用Socket对象包装文件描述符，所有对此文件描述符的读写操作都通过这个对象进行。在对象的析构函数里关闭文件描述符。这样，只要Socket对象还活着，就不会有其他Socket对象跟它有意向的文件描述符，因此也绝不会串话。

## 多线程与fork()
多线程与fork()的协作性很差。  
fork()一般不能在多线程程序中调用，因为Linux的fork()只克隆当前线程的thread of control，不克隆其他线程。

## 多线程与signal
Linux/Unix的信号与多线程可谓是水火不容。单线程时代，编写信号处理函数就是一件棘手的事情。
