# C++多线程系统编程精要
多线程编程面临的思维方式的转变有：
- 当前线程可能随时被切换出去（被抢占）。
- 多线程程序中事件的发生不再有全局统一的先后关系了。

在多核系统中，多个线程是并发执行的，没有统一的全局时钟为每个事件编号。在没有适当同步的情况的下，多个CPU上运行的多个线程中的事件发生先后顺序是无法确定的。在引入适当同步后，事件之间才有happens-before的关系。  

## 基本线程原语的使用

常用的Pthreads函数有：
- 线程的创建和等待结束。
- mutex的创建、销毁、加锁、解锁。
- 条件变量的创建、销毁、等待、通知、广播。

可以酌情使用的有：
- pthread_once。
- pthread_key*。threadlocal变量。

不建议使用的有：
- pthread_rwlock。
- sem_*。
- pthread_{cancel, kill}。系统中如果出现了他们，通常意味着设计出了问题。

不推荐使用读写锁的原因是因为它造成了提高性能的错觉，实际上在很多情况下，与使用最简单的mutex想不，实际上降低了性能。另外，写操作是会阻塞读操作的，如果要求优化读操作的延迟，用读写锁是不合适的。  

## C/C++系统库的线程安全性
对于标准而言，关键的不是定义线程库，而是规定内存模型（memory model）。特别规定一个线程对某个共享变量的修改何时能被其他线程看到，这称为内存序（memory ordering）或内存能见度（memory visibility）。  
绝大部分系统调用都是thread safe的（虽然没有去看是怎么实现thread safe的，姑且在这里认为是加锁的方法）。但是编写安全程序的一个难点在于线程安全是不可组合的，即使调用了两个线程安全的函数，也不能认为这两个函数构成的函数是线程安全的。  

## Linux上的线程标识
不应该使用pthread_self来标识线程。可以通过pid_t获取线程id，同时将线程安全的pid_t换存在thread local中，避免了大量的系统调用。  

## 线程的创建与销毁准则
线程的创建需要准讯的准则：
- 程序不应该在未提前告知的情况下创建自己的“背景线程”。
- 尽量使用相同的方式创建线程。
- 进入main函数之前不应该启动线程。
- 线程的创建最好能在初始化阶段全部完成。

线程销毁的几种方式：
- 自然死亡。从主函数返回，线程正常退出。
- 非自然死亡。从线程主函数抛出异常或线程触发segfault信号等。
- 自杀。
- 他杀。

作者认为不应该从外部杀死线程。  

