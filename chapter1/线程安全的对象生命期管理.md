# 线程安全的对象生命期管理
提出实现线程安全的类是不难的，然而对象的生（constructor)以及死（destructor）是不能通过对象自生拥有的mutex来保护的。引出如何才能做到线程安全的生死控制呢？C++11中的智能指针解决了这一问题。

## 多线程下的析构函数
三个race condition：
- 在即将析构一个对象时，如何确保此时没有其他线程在执行该对象的成员函数？
- 如何保证在调用对象的成员函数时，对象不会其他线程析构？
- 甚至在调用具体对象时，如何得知这个对象是否还活着？

问题的答案：**shared_ptr**以及**weak_ptr**。

### 什么是线程安全的类？
- 多个线程同时访问时表现出正常的行为
- 操作系统对线程的调度不会导致错误的行为出现
- 调用者无需额外的同步（加锁）行为

stl中的大多数类都不是线程安全的。

### 使用lock\_guard封装临界区
RAII机制。


## 保证对象构造时的线程安全
**绝对不要泄漏this指针**。
**不要注册任何回调函数**。
构造函数在执行期间是没有完成初始化的。如果泄漏this给其他对象，且其他对象访问了这个对象，结果是难以预料的。

```C++
// Don't do this
class Foo : public Observer{
    public:
        Foo(Obervable *s){
            s->register_(this); // 错误，非线程安全
        }

        virtual void update();
}
```
两段式构造，如下：
```C++
class Foo : public Observer{
    public:
        Foo(){}

        void observe(Observable *s){
            s->register_(this);
        }

        virtual void update();
}

Foo *pFoo = new Foo;
Observable *s = getSubject();
pFoo->observe(s);
```

即使在构造函数的最后一行也不能泄漏this，如果`Foo`是基类，基类的构造先于派生类，此时派生类可能处于构造中，仍然是线程不安全的。 

## 销毁太难

### mutex在析构函数中不适用

一种可能产生的race condition。
```C++
extern Foo* x;

// thread A
delete x;
x = nullptr;

// thread B
if(x){
    x->update();
}
```
作为数据成员的mutex不能保护析构。

## 对象是否还活着
动态创建的对象是否还活着，从指针上是无法看出来的。

```C++
// unsafe Observer
#include <algorithm>
#include <vector>
#include <stdio.h>

class Observable;

class Observer
{
 public:
  virtual ~Observer();
  virtual void update() = 0;

  void observe(Observable* s);

 protected:
  Observable* subject_;
};

class Observable
{
 public:
  void register_(Observer* x);
  void unregister(Observer* x);

  void notifyObservers()
  {
    for (size_t i = 0; i < observers_.size(); ++i)
    {
      Observer* x = observers_[i];
      if (x) {
        x->update(); // (3)
      }
    }
  }

 private:
  std::vector<Observer*> observers_;
};

Observer::~Observer()
{
  subject_->unregister(this);
}

void Observer::observe(Observable* s)
{
  s->register_(this);
  subject_ = s;
}

void Observable::register_(Observer* x)
{
  observers_.push_back(x);
}

void Observable::unregister(Observer* x)
{
  std::vector<Observer*>::iterator it = std::find(observers_.begin(), observers_.end(), x);
  if (it != observers_.end())
  {
    std::swap(*it, observers_.back());
    observers_.pop_back();
  }
}
```



