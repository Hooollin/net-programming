# 线程同步精要
并发编程的两种基本模型：
- message passing
- shared memory
分布式系统中只能采用messaging passing这一种并行编程的模型。  
单机上，如果照搬分布式系统中的并发模型，更容易保证程序的正确性。shared memory仍在作为一种手段，以备不时之需。  

线程同步的四项原则：
- 最低限度降低共享对象，减少需要同步的场合。
- 使用高级的并发编程构建，包括TaskQueue、Producer-Consumer Queue、CountDountLatch等。
- 不得已要使用底层同步原语时，使用非递归的互斥器（不可重入的锁）和条件变量，慎用读写锁，不用信号量。
- 除了使用atomic整数之外，不要编写lock-free代码。不用内核级的同步原语，不凭空猜测性能。

## mutex
保护critical section。单独使用mutex时，主要是为了保护共享数据。作者提出的原则如下：
- RAII包装Mutex。
- 使用非递归的mutex。
- 不手工调用lock和unlock。
- 思考调用栈上已持有的锁，防止加锁顺序不对导致死锁。

次要原则：
- 不使用跨进程的mutex，进程通信只通过TCP socket。
- 加锁、解锁在同一个线程。（RAII自动保证）

### 只使用不可重入的mutex
可重入锁可能带来难以排查的Bug。

```C++
mutex mu;
std::vector<Foo> foos;

void post(const Foo& f){
    std::lock_guard<mutex> lg;
    foos.push_back(f);
}

void traverse(){
    std::lock_guard<mutex> lg;
    for(auto it = foos.begin(); it != foos.end(); ++it){
        it->doit();
    }
}
```
大多数时间这段代码都不会出错。然而一旦dotit()中调用了post，会出现意想不到的结果：
- mutex是不可重入的，死锁了。
- mutex是可重入的，迭代器可能失效。（内存重新分配）



